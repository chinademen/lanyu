1. 接口模块化(api)，状态管理模块化(store)，请求模块化(services)
	一个api对象，对应一个store，对应一个services

2. 基础组件(components) 和 业务组件(views) 拆分
	将基础组件的业务移到业务组件中，跟业务解耦
	
3. 取消esline检测

4. src下的模块分为：
	assets		静态资源模块
	router		路由模块
	axios		请求封装模块
	config		前端开发人员配置模块(接口配置文件等)
	services	请求处理模块
	stores		状态管理模块
	utils		工具模块
	components  基础组件模块(放置公共组件以及基础组件)
	views		视图模块(业务组件)
	
5. 相对路径换成@导入对应文件或者组件
	作用：相对路径在移动模块文件的时候容易发生引入模块找不到，使用@，可以避免这个问题，在转移文件之后，只需要处理被转移文件的引入问题即可
	注意：如果在ant-design组件中使用@会出现不转换的问题，因为我们默认配置的webpack没有对ant中的@进行处理，所以会报错，这里继续使用相对路径
	
6. stores/index.js中，使用require.context来处理所有的store模块导入，避免每次新增store都要在index.js中使用import导入

7. 优化一个store中存在大量 @observable 的问题
	
8. 优化同一个属性或者方法在不同store中重复保存问题

9. 提取公用store，只在一个组件中使用到的状态，看实际情况不要写在store中每次递归传入，直接写在组件state中

10. 优化每个被观察者对象@observable都是999个元素的问题
	将mobx4.x 升级到 mobx5.x
	MobX 4 和 MobX 5 的不同之处在于后者使用了 ES6 的 proxy 来追踪属性。

11. 拆分被store影响到的组件中的部分，将这些部分独立成更小的组件，避免每次store数据更新，重新render整个大组件
	
12. 在所有渲染 @observable 的组件上使用 @observer
	@observer 只会增强你正在装饰的组件，而不是内部使用了的组件。 所以通常你的所有组件都应该是装饰了的。但别担心，这样不会降低效率，相反 observer 组件越多，渲染效率越高。
	
13. react按需加载组件

14. 抽离公共css样式，如颜色，padding,margin，距离，大小，长度等

15. 图片压缩

16. 各组件css样式文件放置在当前组件中，便于查找维护

17. 一句话注释(一句话都搞不定的注释，表达能力有待提高)

18. 弹窗组件需要可以设置最大弹出数量

19. 能使用react或者原生js的，尽量不要使用jq


























